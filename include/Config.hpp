//
// PTC Tempo Automation API sample client
//
// Copyright Â© 2023 Bio-Rad Laboratories Inc. All rights Reserved
//
// MIT License
//
// SPDX-License-Identifier: MIT
//

#include "Settings.hpp"
#include "CLI/CLI.hpp"
#include "nlohmann/json.hpp"
#include <iostream>

using nlohmann::json;

/**
 * @class Config
 * @brief Saves configuration values to file and retrieves those values from file.
 */
class Config {

    /// Number of spaces to indent output values.
    static const int indent = 2;
    /// Name of config file.
    const std::string configfileName = "config.json";
    /// Contents of config file.
    json configJson;

public:

    /**
     * @brief Adds command line options that are used as configuration values.
     *
     * When the config command is used, values provided on the command line are stored in the config file. When
     * the config command is not used, values provided on the command line override those in the config file.
     *
     * To change these values, a user would use the config command like this.
     * @code
     * tempoclient config --host <host_url>
     * @endcode
     *
     * @param configCommand Manages the command line args for client app.
     */
    void options(CLI::App& configCommand) {
        configCommand.add_option_function<std::string>(
                "--host", [this](const std::string& val) {
                    configJson["host"] = val;
                }, "Set the config host string.");
        configCommand.add_option_function<std::string>(
                "--password", [this](const std::string& val) {
                    configJson["password"] = val;
                }, "Automation user password.");
        configCommand.add_option_function<std::int64_t>(
                "--waitTime", [this](const std::int64_t& val) {
                    configJson["waitTime"] = val;
                }, "How many seconds to wait for a response.");
        configCommand.add_option_function<std::int64_t>(
                "--interval", [this](const std::int64_t val) {
                    configJson["interval"] = val;
                }, "Set interval for lid status and run status refresh");
        configCommand.add_option_function<std::string>(
                "--display", [this](const std::string& val) {
                    configJson["display"] = val;
                }, "Set output display format - options: text or json");
    }

    /**
     * @brief Reads config values from file, and overrides any provided as command line args.
     * @param settings Collection of values provided on the command line.
     */
    void initialize(Settings& settings) {
        settings.host = "http://localhost:8080";
        settings.password = "password";

        std::map<const std::string, std::string*, std::less<>> stringValues = {
                { "host", &settings.host },
                { "password", &settings.password },
                { "display", &settings.displayType }
        };

        std::map<const std::string, std::int64_t*, std::less<>> intValues = {
                { "waitTime", &settings.waitTime},
                { "interval", &settings.interval}
        };

        if (std::ifstream file(configfileName, std::ios::in); file) {
            try {
                std::stringstream strStream;
                strStream << file.rdbuf(); //read the file
                configJson = json::parse(strStream.str());
            } catch (json::exception& ex) {
                std::cerr << ex.what() << std::endl;
                return;
            }
        }

        for (const auto& [key, value] : stringValues) {
            if (configJson.contains(key)) {
                auto& setting = static_cast<std::string&>(*value);
                setting = configJson[key];
            }
        }

        for (const auto& [key, value] : intValues ) {
            if (configJson.contains(key)) {
                auto& setting = static_cast<std::int64_t&>(*value);
                if (configJson[key].is_number_unsigned()) {
                    setting = configJson[key];
                }
            }
        }
    }

    /**
     * @brief Prints out licenses for all third party open source projects used in the client app.
     */
    static void license() {

        // include the license file as const strings.
        // These include files are generated by cmake.
        const std::string bioradLicense =
#include "bioradLicense.h"
        ;
        const std::string httplibLicense =
#include "httplibLicense.h"
        ;
        const std::string cli11License =
#include "cli11License.h"
        ;
        const std::string jsonLicense =
#include "jsonLicense.h"
        ;

        const std::string license = R"foo(Except for the MATERIALS discussed below, Bio-Rad's PTC Tempo Client example app )foo" "\n"
                                    R"foo((is licensed for use and distribution under the following terms: )foo" "\n";
        const std::string licenseMore = R"foo(Bio-Rad's PTC Tempo Client example app incorporates third-party materials identified )foo" "\n"
                                        R"foo(below (together, the "MATERIALS") subject to free, open-source, or public-source )foo" "\n"
                                        R"foo(licenses (each an "OPEN LICENSE"). The terms of applicable Open LICENSES govern )foo" "\n"
                                        R"foo(Bio-Rad's distribution and your use of the MATERIALS. Bio-Rad and the third-party  )foo" "\n"
                                        R"foo(authors, licensors, and distributors of the MATERIALS disclaim warranties and )foo" "\n"
                                        R"foo(liability arising from all use and distribution of the MATERIALS.)foo" "\n";

        R"foo((is licensed for use and distribution under the following terms: )foo" "\n";

        std::cout << std::endl << license << bioradLicense << std::endl << licenseMore << std::endl;
        std::cout << std::endl << "cpp-httplib:" << std::endl << "project homepage: https://github.com/yhirose/cpp-httplib ";
        std::cout << std::endl << httplibLicense;
        std::cout << std::endl << "CLI11:" << std::endl << "project homepage: https://github.com/CLIUtils/CLI11 ";
        std::cout << std::endl << cli11License << std::endl;
        std::cout << std::endl << "nlohmann json:" << std::endl << "project homepage: https://github.com/nlohmann/json ";
        std::cout << std::endl << jsonLicense << std::endl << std::endl;

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
        const std::string opensslLicense =
#include "opensslLicense.h"
        ;
        std::cout << std::endl << "OPENSSL:" << std::endl << opensslLicense << std::endl << std::endl;
#endif

    }

    /**
     * @brief Stores config values to file.
     */
    void save() const {
        std::ofstream file;
        file.open(configfileName, std::ios::out);
        file << configJson.dump(indent);
    }

    /**
     * @brief print Prints configuration values.
     * @param displayFormat Format used for display: either text or json.
     */
    void print(std::string_view displayFormat = "json") const {
        if (displayFormat == "text") {
            std::string res = configJson.dump(indent);
            std::cout << formatResponseForTextDisplay(res) << std::endl;
        }
        else {
            std::cout << std::endl << configJson.dump(indent) << std::endl << std::endl;
        }
    }

    /**
     * @brief Converts json to text for display.
     * @param res One or more configuration values as stored in json format.
     * @return String with json formatting removed.
     */
    static std::string& formatResponseForTextDisplay(std::string& res) {
        const std::string notPrint = "[]{}\",";
        res.erase(remove_if(res.begin(), res.end(), [&notPrint](const char& c) {
            return notPrint.find(c) != std::string::npos;
        }), res.end());
        return res;
    }
};
